#pragma once
#include <iostream>

class Fraction {
public:
    Fraction(int num = 0, int den = 1) {
        if (den == 0) {
            std::cout << " D-r cant be 0." << std::endl;
            m_numerator = 0; 
            m_denominator = 1; 
        } else {
            m_numerator = num;
            m_denominator = den;
        }
    }

    int numerator() const { return m_numerator; }
    int denominator() const { return m_denominator; }
    
    void setNumerator(int num) { m_numerator = num; }
    void setDenominator(int den) { 
        if (den == 0) {
            std::cout << "D-r cant be 0." << std::endl;
            return; 
        }
        m_denominator = den; 
    }

    Fraction operator+(Fraction b);
    Fraction operator-(Fraction b);
    Fraction operator*(Fraction b);
    Fraction operator/(Fraction b);

    bool operator==(Fraction b);
    bool operator!=(Fraction b);
    bool operator<(Fraction b);
    bool operator>(Fraction b);

    bool operator<<(Fraction b);//check whatfor lower
    bool operator>>(Fraction b);
    
    Fraction operator^(Fraction b);
    
private:
    int m_numerator;
    int m_denominator;
};






Fraction Fraction::operator+(Fraction b) {
    Fraction result;
    result.setNumerator(m_numerator * b.denominator() + b.numerator() * m_denominator);
    result.setDenominator(m_denominator * b.denominator());
    return result;
}

Fraction Fraction::operator-(Fraction b) {
    Fraction result;
    result.setNumerator(m_numerator * b.denominator() - b.numerator() * m_denominator);
    result.setDenominator(m_denominator * b.denominator());
    return result;
}

Fraction Fraction::operator*(Fraction b) {
    Fraction result;
    result.setNumerator(m_numerator * b.numerator());
    result.setDenominator(m_denominator * b.denominator());
    return result;
}

Fraction Fraction::operator/(Fraction b) {
    if (b.numerator() == 0) {
        std::cout << "Cant divide by fraction with 0 in n-r's place." << std::endl;
        return Fraction(0, 1);
    }
    Fraction result;
    result.setNumerator(m_numerator * b.denominator());
    result.setDenominator(m_denominator * b.numerator());
    return result;
}

bool Fraction::operator==(Fraction b) {
    return (m_numerator * b.denominator() == b.numerator() * m_denominator);
}

bool Fraction::operator!=(Fraction b) {
    return !(*this == b);
}

bool Fraction::operator<(Fraction b) {
    return (m_numerator * b.denominator() < b.numerator() * m_denominator);
}

bool Fraction::operator>(Fraction b) {
    return (m_numerator * b.denominator() > b.numerator() * m_denominator);
}


//uniqueMeth1(it finds whose num-r is bigger)
bool Fraction::operator<<(Fraction b) {
    return (m_numerator < b.numerator());
}

//uniqueMeth2(it finds whose din-r is bigger)
bool Fraction::operator>>(Fraction b) {
    return (m_denominator() < b.m_denominator());
}


/*makeDecrease
Fraction Fraction:: operator^(Fraction b)
{
    if(b.numerator)
    
}
unsigned int greatest_common_divisor(unsigned int a, unsigned int b) {
  if (a % b == 0)
    return b;
  if (b % a == 0)
    return a;
  if (a > b)
    return greatest_common_divisor(a%b, b);
  return greatest_common_divisor(a, b%a);
}

*/








/*ostlos dodelat 

1)приведение дроби к несократимой (допускается как в виде публичного,
так и закрытого метода, при условии, что закрытый метод вызывается при операциях,
результатом которых может быть сократимая дробь);
2)- ввод/вывод дроби в консоль;


